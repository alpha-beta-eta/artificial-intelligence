#lang racket
(provide (all-defined-out))
;<pattern> ::= <constant>
;           |  <variable>
;           |  (% <pattern>*)
;           |  (list <pattern0>*)
;<pattern0> ::= <constant>
;            |  <variable>
;            |  <segment-variable>
;            |  (% <pattern0>*)
;            |  (: <pattern0>*)
;            |  (list <pattern0>*)
;<variable> ::= (? <symbol>)
;<segment-variable> ::= (?? <symbol>)
;<datum> ::= <constant>
;         |  (<datum>*)
;<constant> ::= <number>
;            |  <boolean>
;            |  <symbol>
(define (constant? x)
  (or (number? x)
      (boolean? x)
      (symbol? x)))
(define (variable-name variable)
  (cadr variable))
(define (empty-dict) '())
(define (extend-dict name value dict)
  (cons (list name value) dict))
(define (lookup-binding name dict)
  (assq name dict))
(define (binding-value binding)
  (cadr binding))
(define (match-constant constant)
  (lambda (datum* dict fail succeed)
    (cond ((null? datum*) (fail))
          ((eqv? (car datum*) constant)
           (succeed fail dict (cdr datum*)))
          (else (fail)))))
(define (match-element name)
  (lambda (datum* dict fail succeed)
    (cond ((null? datum*) (fail))
          ((lookup-binding name dict)
           => (lambda (binding)
                (let ((value (binding-value binding)))
                  (if (equal? (car datum*) value)
                      (succeed fail dict (cdr datum*))
                      (fail)))))
          (else
           (let ((dict^ (extend-dict name (car datum*) dict)))
             (succeed fail dict^ (cdr datum*)))))))
(define (match-segment name)
  (lambda (datum* dict fail succeed)
    (let ((binding (lookup-binding name dict)))
      (if binding
          (let ((value (binding-value binding)))
            (let iter ((value value) (datum* datum*))
              (cond ((null? value)
                     (succeed fail dict datum*))
                    ((null? datum*) (fail))
                    ((equal? (car value) (car datum*))
                     (iter (cdr value) (cdr datum*)))
                    (else (fail)))))
          (let iter ((value '()) (datum* datum*)) 
            (succeed (lambda ()
                       (if (null? datum*)
                           (fail)
                           (iter (append value (list (car datum*)))
                                 (cdr datum*))))
                     (extend-dict name value dict)
                     datum*))))))
(define succeed-matcher
  (lambda (datum* dict fail succeed)
    (succeed fail dict datum*)))
(define fail-matcher
  (lambda (datum* dict fail succeed)
    (fail)))
(define (match-seq2 m1 m2)
  (lambda (datum* dict fail succeed)
    (m1 datum* dict fail
        (lambda (fail dict datum*)
          (m2 datum* dict fail succeed)))))
(define (match-sequence . matcher*)
  (if (null? matcher*)
      succeed-matcher
      (let iter ((matcher (car matcher*))
                 (matcher* (cdr matcher*)))
        (if (null? matcher*)
            matcher
            (iter (match-seq2 matcher (car matcher*))
                  (cdr matcher*))))))
(define (match-list . matcher*)
  (let ((matcher (apply match-sequence matcher*)))
    (lambda (datum* dict fail succeed)
      (cond ((null? datum*) (fail))
            ((or (pair? (car datum*)) (null? (car datum*)))
             ;(list? (car datum*))
             (matcher (car datum*) dict fail
                      (lambda (fail dict rest)
                        (if (null? rest)
                            (succeed fail dict (cdr datum*))
                            (fail)))))
            (else (fail))))))
(define (match-c2 m1 m2)
  (lambda (datum* dict fail succeed)
    (m1 datum* dict
        (lambda () (m2 datum* dict fail succeed))
        succeed)))
(define (match-choices . matcher*)
  (if (null? matcher*)
      fail-matcher
      (let iter ((matcher (car matcher*))
                 (matcher* (cdr matcher*)))
        (if (null? matcher*)
            matcher
            (iter (match-c2 matcher (car matcher*))
                  (cdr matcher*))))))
(define (compile-pattern pattern)
  (define (compile pattern)
    (if (constant? pattern)
        (match-constant pattern)
        (case (car pattern)
          ((?) (match-element (variable-name pattern)))
          ((%) (let ((matcher* (map compile (cdr pattern))))
                 ;use compile, not compile0
                 (apply match-choices matcher*)))
          ((list) (let ((matcher* (map compile0 (cdr pattern))))
                    (apply match-list matcher*))))))
  (define (compile0 pattern0)
    (if (constant? pattern0)
        (match-constant pattern0)
        (case (car pattern0)
          ((?) (match-element (variable-name pattern0)))
          ((??) (match-segment (variable-name pattern0)))
          ((%) (let ((matcher* (map compile0 (cdr pattern0))))
                 (apply match-choices matcher*)))
          ((:) (let ((matcher* (map compile0 (cdr pattern0))))
                 (apply match-sequence matcher*)))
          ((list) (let ((matcher* (map compile0 (cdr pattern0))))
                    (apply match-list matcher*))))))
  (compile pattern))
(define (run-matcher pattern fail succeed)
  (let ((matcher (compile-pattern pattern)))
    (lambda (datum)
      (matcher (list datum) (empty-dict) fail succeed))))
(define f0
  (lambda () #f))
(define s0
  (lambda (fail dict datum*)
    (printf "~s\n" dict)
    (fail)))
(define (run pattern)
  (run-matcher pattern f0 s0))